import Phaser from 'phaser'
import { Plugin as ActorPlugin, Actor } from '@eriengine/plugin-actor'
import { Plugin as IsometricScenePlugin } from '@eriengine/plugin-isometric-scene'
import { Plugin as IsometricCursorPlugin } from '@eriengine/plugin-isometric-cursor'
import { Plugin as DialoguePlugin } from '@eriengine/plugin-dialogue'
import { Plugin as FogOfWarPlugin } from '@eriengine/plugin-fog-of-war'

{{ DATA_LISTS }}
{{ STORAGE_LISTS }}

type ScriptCallback = (this: EriengineScene, ...args: any) => void

interface SceneMap {
    walls: [number, number, string][]
    floors: [number, number, string][]
    actors: { name: string, x: number, y: number }[]
}

interface SceneStorage {
    Script: {
        [key: string]: {
            [key: string]: ScriptCallback
        }
    },
    Map: {
        [key: string]: {
            default: SceneMap
        }
    }
}

export default class EriengineScene extends Phaser.Scene {

    private static ApplicationId: string = '{{ APPLICATION_ID }}'

    protected actor!: ActorPlugin
    protected isometric!: IsometricScenePlugin
    protected cursor!: IsometricCursorPlugin
    protected dialogue!: DialoguePlugin
    protected fow!: FogOfWarPlugin

    protected __scripts: Map<string, ScriptCallback[]> = new Map
    protected __map: SceneMap = { walls: [], floors: [], actors: [] }

    /** 게임데이터를 저장하는데 사용된 키 목록입니다 */
    protected get saveKeys(): string[] {
        return Object.keys(window.localStorage)
            .filter((key: string): boolean => key.indexOf(this.getSaveKey('')) === 0)
            .map((key: string): string => key.replace(this.getSaveKey(''), ''))
    }

    protected generateMap(storages: typeof Storages, key: keyof typeof storages): void {
        const storage: SceneStorage = storages[key] as unknown as SceneStorage
        if (!storage) {
            throw `${this.scene.key} 씬에 스토리지 정보가 없습니다.`
        }
        this.__map = Object.values(storage.Map)[0].default
    }

    protected generateScript(storages: typeof Storages, key: keyof typeof storages): void {
        const storage: SceneStorage = storages[key] as unknown as SceneStorage
        if (!storage) {
            throw `${this.scene.key} 씬에 스토리지 정보가 없습니다.`
        }
        const script = storage.Script
        for (const name in script) {
            const callbackData = script[name as keyof typeof script]
            for (const type in callbackData) {
                if (!this.__scripts.has(type)) {
                    this.__scripts.set(type, [])
                }
                const callback: ScriptCallback = callbackData[type as keyof typeof callbackData]
                this.__scripts.get(type)!.push(callback)
            }
        }
    }

    protected runScript(callbacks?: ((...args: any) => void)[], ...args: any): void {
        if (!callbacks)  {
            return
        }
        callbacks.forEach((callback): void => callback.call(this, args))
    }

    private loadImage(): void {
        for (const name in Images) {
            const { key, asset } = Images[name as keyof typeof Images]
            if (this.textures.exists(key)) {
                continue
            }
            this.load.image(key, asset)
        }
    }

    private loadAudio(): void {
        for (const name in Audios) {
            const { key, asset } = Audios[name as keyof typeof Audios]
            if (this.cache.audio.exists(key)) {
                continue
            }
            this.load.audio(key, asset)
        }
    }

    private loadVideo(): void {
        for (const name in Videos) {
            const { key, asset } = Videos[name as keyof typeof Videos]
            if (this.cache.video.exists(key)) {
                continue
            }
            this.load.video(key, asset)
        }
    }

    private loadSpritesheet(): void {
        for (const name in Animations) {
            const { key, asset, frameWidth, frameHeight } = Animations[name as keyof typeof Animations]
            if (this.textures.exists(key)) {
                continue
            }
            this.load.spritesheet(key, asset, { frameWidth, frameHeight })
        }
    }

    protected loadAssets(): void {
        this.load.setPath('Asset/')
        this.loadImage()
        this.loadAudio()
        this.loadVideo()
        this.loadSpritesheet()
    }

    protected createAnimation(): void {
        for (const name in Animations) {
            const { key, frameRate, start, end, repeat } = Animations[name as keyof typeof Animations]
            if (this.anims.exists(key)) {
                continue
            }
            this.anims.create({
                key,
                frames: this.anims.generateFrameNumbers(key, { start, end }),
                frameRate,
                repeat
            })
        }
    }

    private getSaveKey(key: string): string {
        return `${EriengineScene.ApplicationId}-save-${key}`
    }

    /**
     *  게임 데이터를 저장합니다. 너무 큰 데이터는 용량 상 저장할 수 없습니다.
     *  @param key      게임 데이터를 저장할 키 값입니다.
     *  @param data     저장할 게임 데이터입니다.
     */
    protected setSaveData(key: string, data: Types.Json): void {
        key = this.getSaveKey(key)
        const stringify: string = JSON.stringify(data)
        window.localStorage.setItem(key, stringify)
    }

    /**
     *  저장된 게임 데이터를 반환합니다. 저장된 값이 없다면 null을 반환합니다.
     *  @param key      게임 데이터를 저장하는데 사용된 키 값입니다.
     */
    protected getSaveData(key: string): Types.Json|null {
        key = this.getSaveKey(key)
        const raw: string|null = window.localStorage.getItem(key)
        if (!raw) {
            return null
        }
        return JSON.parse(raw)
    }

    /**
     *  저장된 게임 데이터를 삭제합니다. 매개변수로 넘긴 키 값에 해당하는 게임 데이터가 있었다면 true, 없었다면 false를 반환합니다.
     *  @param key      게임 데이터를 저장하는데 사용된 키 값입니다.
     */
    protected removeSaveData(key: string): boolean {
        key = this.getSaveKey(key)
        const raw: string|null = window.localStorage.getItem(key)
        if (!raw) {
            return false
        }
        window.localStorage.removeItem(key)
        return true
    }

    /**
     *  저장된 모든 게임 데이터를 삭제합니다.
     */
    protected clearSaveData(): void {
        for (const key of this.saveKeys) {
            this.removeSaveData(key)
        }
    }

}