import Phaser from 'phaser'
import { Plugin as ActorPlugin, Actor } from '@eriengine/plugin-actor'
import { Plugin as IsometricScenePlugin } from '@eriengine/plugin-isometric-scene'
import { PointerPlugin as IsometricCursorPlugin, SelectPlugin as IsometricSelectPlugin } from '@eriengine/plugin-isometric-cursor'
import { DialoguePlugin, ModalPlugin } from '@eriengine/plugin-dialogue'
import { Plugin as FogOfWarPlugin } from '@eriengine/plugin-fog-of-war'

{{ DATA_LISTS }}
{{ STORAGE_LISTS }}

type ScriptCallback = (this: BaseScene, ...args: any) => void

interface Point2 {
    x: number
    y: number
}

interface SceneMap {
    side: number
    walls:  { key: string, alias: string, x: number, y: number, scale: number, isSensor: boolean }[]
    floors: { key: string, x: number, y: number }[]
}

interface SceneStorage {
    Script: {
        [key: string]: {
            [key: string]: ScriptCallback
        }
    },
    Map: {
        [key: string]: {
            default: SceneMap
        }
    }
}

interface SaveData {
    date: number
    thumbnail: string
    data: Types.Json
}


/**
 * 
 *    ██╗    ██╗     █████╗     ██████╗     ███╗   ██╗    ██╗    ███╗   ██╗     ██████╗ ██╗
 *    ██║    ██║    ██╔══██╗    ██╔══██╗    ████╗  ██║    ██║    ████╗  ██║    ██╔════╝ ██║
 *    ██║ █╗ ██║    ███████║    ██████╔╝    ██╔██╗ ██║    ██║    ██╔██╗ ██║    ██║  ███╗██║
 *    ██║███╗██║    ██╔══██║    ██╔══██╗    ██║╚██╗██║    ██║    ██║╚██╗██║    ██║   ██║╚═╝
 *    ╚███╔███╔╝    ██║  ██║    ██║  ██║    ██║ ╚████║    ██║    ██║ ╚████║    ╚██████╔╝██╗
 *     ╚══╝╚══╝     ╚═╝  ╚═╝    ╚═╝  ╚═╝    ╚═╝  ╚═══╝    ╚═╝    ╚═╝  ╚═══╝     ╚═════╝ ╚═╝
 *                                                                                        
 *                                                                 
 *  주의!
 *  절대로 BaseScene 내용을 건들지 마십시오.
 *  만일 추가하고 싶은 내용이 있다면 BaseScene을 상속받은 씬 파일을 수정하십시오.
 *  하지만 가장 좋은 방법은, 씬의 스크립트를 이용하는 것입니다.
 * 
 *  
 *  모든 씬은 이 BaseScene을 상속받습니다.
 *  BaseScene은 에리엔진의 씬이 정상적으로 동작하기 위해 필수적인 내용을 가지고 있는 클래스입니다.
 *  BaseScene은 프로젝트가 실행될 때 마다 새롭게 재생성됩니다. 따라서 이 파일을 수정하여도 전부 초기화되므로 건들지 마십시오.
 * 
 */
export default class BaseScene extends Phaser.Scene {

    private static ApplicationId: string = '{{ APPLICATION_ID }}'

    protected actor!: ActorPlugin
    protected isometric!: IsometricScenePlugin
    protected cursor!: IsometricCursorPlugin
    protected select!: IsometricSelectPlugin
    protected dialogue!: DialoguePlugin
    protected modal!: ModalPlugin
    protected fow!: FogOfWarPlugin

    protected __scripts: Map<string, ScriptCallback[]> = new Map
    protected __map: SceneMap = { side: 2000, walls: [], floors: [] }

    /** 게임데이터를 저장하는데 사용된 키 목록입니다 */
    protected get saveKeys(): string[] {
        return Object.keys(window.localStorage)
            .filter((key: string): boolean => key.indexOf(this.getSaveKey('')) === 0)
            .map((key: string): string => key.replace(this.getSaveKey(''), ''))
    }

    protected generateMap(storages: typeof Storages, key: keyof typeof storages): void {
        const storage: SceneStorage = storages[key] as unknown as SceneStorage
        if (!storage) {
            throw `${this.scene.key} 씬에 스토리지 정보가 없습니다.`
        }
        this.__map = Object.values(storage.Map)[0].default
    }

    protected generateScript(storages: typeof Storages, key: keyof typeof storages): void {
        const storage: SceneStorage = storages[key] as unknown as SceneStorage
        if (!storage) {
            throw `${this.scene.key} 씬에 스토리지 정보가 없습니다.`
        }
        const script = storage.Script
        for (const name in script) {
            const callbackData = script[name as keyof typeof script]
            for (const type in callbackData) {
                if (!this.__scripts.has(type)) {
                    this.__scripts.set(type, [])
                }
                const callback: ScriptCallback = callbackData[type as keyof typeof callbackData]
                this.__scripts.get(type)!.push(callback)
            }
        }
    }

    protected runScript(callbacks?: ((...args: any) => void)[], ...args: any): void {
        if (!callbacks)  {
            return
        }
        callbacks.forEach((callback): void => callback.call(this, args))
    }

    private loadImage(): void {
        for (const name in Images) {
            const { key, asset } = Images[name as keyof typeof Images]
            if (this.textures.exists(key)) {
                continue
            }
            this.load.image(key, asset)
        }
    }

    private loadAudio(): void {
        for (const name in Audios) {
            const { key, asset } = Audios[name as keyof typeof Audios]
            if (this.cache.audio.exists(key)) {
                continue
            }
            this.load.audio(key, asset)
        }
    }

    private loadVideo(): void {
        for (const name in Videos) {
            const { key, asset } = Videos[name as keyof typeof Videos]
            if (this.cache.video.exists(key)) {
                continue
            }
            this.load.video(key, asset)
        }
    }

    private loadSpritesheet(): void {
        for (const name in Animations) {
            const { key, asset, frameWidth, frameHeight } = Animations[name as keyof typeof Animations]
            if (this.textures.exists(key)) {
                continue
            }
            this.load.spritesheet(key, asset, { frameWidth, frameHeight })
        }
    }

    protected loadAssets(): void {
        this.load.setPath('Asset/')
        this.loadImage()
        this.loadAudio()
        this.loadVideo()
        this.loadSpritesheet()
    }

    protected createAnimation(): void {
        for (const name in Animations) {
            const { key, frameRate, start, end, repeat } = Animations[name as keyof typeof Animations]
            if (this.anims.exists(key)) {
                continue
            }
            this.anims.create({
                key,
                frames: this.anims.generateFrameNumbers(key, { start, end }),
                frameRate,
                repeat
            })
        }
    }

    protected createMap(): void {
        this.isometric.setWorldSize(this.__map.side)

        for (const { key, alias, x, y, scale, isSensor } of this.__map.walls)  {
            let animsKey: string|undefined
            if (this.anims.exists(key)) {
                animsKey = key
            }
            const wall = this.isometric.setWalltile(x, y, key, undefined, animsKey)
            wall.setScale(scale)
            wall.setSensor(isSensor)
            wall.setDataEnabled()
            wall.data.set('alias', alias)
        }
        for (const { key, x, y } of this.__map.floors) {
            let animsKey: string|undefined
            if (this.anims.exists(key)) {
                animsKey = key
            }
            this.isometric.setFloortile(x, y, key, undefined, animsKey)
        }
    }

    private getSaveKey(key: string): string {
        return `${BaseScene.ApplicationId}-save-${key}`
    }

    private createThumbnail(type: 'image/png'|'image/jpeg' = 'image/jpeg', quality: number = 0.5, size: number = 100): Promise<string> {
        return new Promise((resolve, reject): void => {
            this.renderer.snapshot((image): void => {
                image = image as HTMLImageElement
                const canvas = document.createElement('canvas')
                const ctx = canvas.getContext('2d')
                if (!ctx) {
                    return reject('CanvasRenderingContext2DSettings generate error.')
                }
                const ratio: number = image.naturalWidth / image.naturalHeight
                if (image.naturalWidth > image.naturalHeight) {
                    canvas.width    = size
                    canvas.height   = size / ratio
                }
                else {
                    canvas.width    = size * ratio
                    canvas.height   = size
                }
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height)
                resolve(canvas.toDataURL(type, quality))
            }, 'image/png', 1)
        })
    }

    /**
     *  게임 데이터를 저장합니다. 너무 큰 데이터는 용량 상 저장할 수 없습니다.  
     *  총 저장공간은 5MB가 한도입니다.
     *  @param key      게임 데이터를 저장할 키 값입니다.
     *  @param data     저장할 게임 데이터입니다.
     */
    protected async setSaveData(key: string, data: Types.Json): Promise<SaveData> {
        key = this.getSaveKey(key)
        const date: number          = Date.now()
        const thumbnail: string     = await this.createThumbnail()
        const saveData: SaveData    = { date, thumbnail, data }
        const stringify: string     = JSON.stringify(saveData)

        window.localStorage.setItem(key, stringify)
        return saveData
    }

    /**
     *  저장된 게임 데이터를 반환합니다. 저장된 값이 없다면 null을 반환합니다.
     *  @param key      게임 데이터를 저장하는데 사용된 키 값입니다.
     */
    protected getSaveData(key: string): Types.Json|null {
        key = this.getSaveKey(key)
        const raw: string|null = window.localStorage.getItem(key)
        if (!raw) {
            return null
        }
        return JSON.parse(raw)
    }

    /**
     *  저장된 게임 데이터를 삭제합니다. 매개변수로 넘긴 키 값에 해당하는 게임 데이터가 있었다면 true, 없었다면 false를 반환합니다.
     *  @param key      게임 데이터를 저장하는데 사용된 키 값입니다.
     */
    protected removeSaveData(key: string): boolean {
        key = this.getSaveKey(key)
        const raw: string|null = window.localStorage.getItem(key)
        if (!raw) {
            return false
        }
        window.localStorage.removeItem(key)
        return true
    }

    /**
     *  저장된 모든 게임 데이터를 삭제합니다.
     */
    protected clearSaveData(): void {
        for (const key of this.saveKeys) {
            this.removeSaveData(key)
        }
    }

    init(data: object = {}): void {
        this.runScript(this.__scripts.get('onSceneInit'), data)
        this.events.once(Phaser.Scenes.Events.DESTROY, () => this.runScript(this.__scripts.get('onSceneDestroy')))
    }

    preload(): void {
        this.runScript(this.__scripts.get('onScenePreload'))
        this.loadAssets()
    }

    create(): void {
        this.createAnimation()
        this.createMap()
        this.runScript(this.__scripts.get('onSceneCreate'))
    }
    
    update(time: number, delta: number): void {
        this.runScript(this.__scripts.get('onSceneUpdate'), time, delta)
    }

}